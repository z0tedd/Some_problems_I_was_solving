# Solutions

## 1

Ограничение по времени на тест: 1 секунда

Ограничение по памяти на тест: 256 мегабайт

Для контроля функциональности сети мобильной связи оператор
собирает большое количество внутренней статистики.
В частности, для каждой базовой станции записывается количество установленных соединений,
в которых участвовали абоненты, находящиеся на территории этой базовой станции.

В этой задаче в момент установления соединения каждый абонент находится на территории
ровно одной базовой станции; установление соединения увеличивают из счётчики на 1
(назовём это соединением типа 1). Если два абонента находятся на территории
одной и той же базовой станции, то счётчик соединений для этой станции
увеличивается на 1 за каждого абонента (назовём это соединением типа 2).

Вам даётся список количества соединений по всем n базовым станциям,
собранный за последние несколько дней. Требуется выяснить, какое наименьшее количество
соединений типа 2 могло быть среди соединений, информация о которых была собрана.

Входные данные:

Первая строка входных данных содержит целое число n ( 1 ≤ n ≤ 105 ) — количество
базовых станций. i -я из последующих n строк содержит по одному целому числу ai
( 0 ≤ ai ≤ 1 ′ 000 ′ 000 ) — значение счётчика соединений i -й базовой станции.
Гарантируется, что сумма всех ai чётна.

Выходные данные:

Выведите одно целое число — наименьшее количество соединений типа 2,
которое могло быть среди соединений, сформировавших заданный список значений счётчика.

Примеры:
Входные данные Выходные данные
5 0
4
3
2
1
0

Входные данные Выходные данные
1 2
4

```cpp
def main():
    n = int(input())
    a = [int(input()) for _ in range(n)]
    S = sum(a)
    m = S // 2
    P1 = 0

    for ai in a:
        P1 += min(ai, S - ai)
    P = P1 // 2
    L_min = m - P
    print(L_min)

main()
```

## 2

Назовём строку MTS-строкой, если из неё можно удалить все символы, кроме трёх так,
чтобы оставшиеся три буквы образовывали слово MTS.Дана строка, состоящая из строчных
латинских букв и построенная случайным равновероятным выбором среди всех строк
длины п. Какова вероятность, что эта строка является ли она MTS-строкой?
Входные данные
Первая строка входных данных содержит одно целое число п - длину строки (1 n 105).
Выходные данные
Можно показать, что вероятность можно единственным способом представить в виде
дроби p/q.где ри q взаимно просты, а знаменатель взаимно прост с 998 244 353.
Выведите значение p-q 'по модулю 998 244 353, то есть такое число 0 x5 998 244 353,
что q-хдаёт при делении на 998 244 353 такой же остаток, что и р.

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MOD = 998244353;

ll PowMod(ll a, ll b, ll mod_val) {
  ll res = 1;
  a %= mod_val;
  while (b > 0) {
    if (b & 1) {
      res = res * a % mod_val;
    }
    a = a * a % mod_val;
    b >>= 1;
  }
  return res;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);

  int n;
  cin >> n;

  ll dp0 = 1;
  ll dp1 = 0;
  ll dp2 = 0;
  ll dp3 = 0;

  for (int i = 0; i < n; i++) {
    ll temp_dp0 = dp0 * 25 % MOD;
    ll temp_dp1 = (dp0 + dp1 * 25) % MOD;
    ll temp_dp2 = (dp1 + dp2 * 25) % MOD;
    ll temp_dp3 = (dp2 + dp3 * 26) % MOD;

    dp0 = temp_dp0;
    dp1 = temp_dp1;
    dp2 = temp_dp2;
    dp3 = temp_dp3;
  }

  ll p = dp3;
  ll q = PowMod(26, n, MOD);
  ll q_inv = PowMod(q, MOD - 2, MOD);
  ll answer = p * q_inv % MOD;

  std::cout << answer;
}
```

## 4

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MOD = 998244353;

ll PowMod(ll a, ll b, ll mod_val) {
  ll res = 1;
  a %= mod_val;
  while (b > 0) {
    if (b & 1) {
      res = res * a % mod_val;
    }
    a = a * a % mod_val;
    b >>= 1;
  }
  return res;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);

  int n;
  cin >> n;

  ll dp0 = 1;
  ll dp1 = 0;
  ll dp2 = 0;
  ll dp3 = 0;

  for (int i = 0; i < n; i++) {
    ll temp_dp0 = dp0 * 25 % MOD;
    ll temp_dp1 = (dp0 + dp1 * 25) % MOD;
    ll temp_dp2 = (dp1 + dp2 * 25) % MOD;
    ll temp_dp3 = (dp2 + dp3 * 26) % MOD;

    dp0 = temp_dp0;
    dp1 = temp_dp1;
    dp2 = temp_dp2;
    dp3 = temp_dp3;
  }

  ll p = dp3;
  ll q = PowMod(26, n, MOD);
  ll q_inv = PowMod(q, MOD - 2, MOD);
  ll answer = p * q_inv % MOD;

  std::cout << answer;
}
```
